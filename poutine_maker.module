<?php
/**
 * @file
 *
 * Defines a custom field for constructing a custom poutine.
 */

module_load_include('inc', 'poutine_maker', 'poutine_maker.toppings');

/**
 * Implements hook_field_info().
 *
 * Here we tell Drupal about our custom fields. In this case
 * we only have one. Its machine-readable name is 'poutine_maker_poutine_maker'
 * because the convention is 'modulename_fieldname'.
 *
 * We also define the machine names of the widget and the formatter.
 */
function poutine_maker_field_info() {
  return array(
    'poutine_maker_poutine_maker' => array(
      'label' => t('Custom Poutine'),
      'description' => t('Custom Poutine Field'),
      'default_widget' => 'poutine_maker_poutine_maker_in',
      'default_formatter' => 'poutine_maker_poutine_maker_out',
    ),
  );
}

/**
 * Implements hook_field_formatter_info().
 *
 * Here we tell Drupal about our custom formatters. In this
 * case we only have one. Note that our formatter works on
 * the field type 'poutine_maker_poutine_maker', which is
 * the machine-readable name we defined in poutine_maker_field_info().
 */
function poutine_maker_field_formatter_info() {
  return array(
    'poutine_maker_poutine_maker_out' => array(
      'label' => t('Default'),
      'field types' => array('poutine_maker_poutine_maker'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 *
 * This function gives Drupal a structured array, which
 * defines how the data stored in the field should be rendered.
 */
function poutine_maker_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  foreach ($items as $delta => $item) {
    $element[$delta] = poutine_maker_format_field($item);
  }
  return $element;
}

/**
 * Helper to render a single formatted entry
 */
function poutine_maker_format_field($item) {
  $element = array(
    '#type' => 'container',
    '#attributes' => array('class' => array('field-item')),
    'text' => array(
      '#markup' => 'poutine_maker rendering not implemented',
    ),
  );
  return $element;
}

/**
 * Implements hook_field_widget_info().
 *
 * Here we tell Drupal about our custom widgets. In this
 * case we only have one. As with poutine_maker_field_formatter_info(),
 * we tell Drupal which fields our widget works with (in this case, just
 * 'poutine_maker_poutine_maker').
 */
function poutine_maker_field_widget_info() {
  return array(
    'poutine_maker_poutine_maker_in' => array(
      'label' => t('Default'),
      'field types' => array('poutine_maker_poutine_maker'),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 *
 * http://api.drupal.org/api/drupal/modules--field--field.api.php/function/hook_field_widget_form/7
 * 
 * Here we define a form element that the user inputs data
 * into. If we have a complex custom field, we can have many sub-elements
 * organized into fieldsets.
 */
function poutine_maker_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  // $field_name is the name of the field instance. This is the
  // name that the administrator gives the field instance when
  // attaching it to an entity.
  $field_name = $instance['field_name'];

  // $process is a callback that we will attach to fieldsets in order
  // to 'flatten' the form values. This is so we can store
  // nested values in a 'flat' DB table.
  $fieldset_info = element_info('fieldset');
  $process = array_merge($fieldset_info['#process'], array('poutine_maker_ignore_parent'));

  // Is this field instance required?
  // We can use this $required value to make sub-elements of the
  // widget form required.
  $required = $element['#required'];

  // $item is where the current saved values are stored
  $item =& $items[$delta];

  // $element is already populated with #title, #description, #delta,
  // #required, #field_name, etc.
  //
  // In this example, $element is a fieldset, but it could be any element
  // type (textfield, checkbox, etc.)
  $element += array(
    '#type' => 'fieldset',
  );

  // Array keys in $element correspond roughly
  // to array keys in $item, which correspond
  // roughly to columns in the database table.
  $element['name'] = array(
    '#title' => t('Name'),
    '#type' => 'textfield',
    '#required' => $required,
    // use #default_value to prepopulate the element
    // with the current saved value
    '#default_value' => isset($item['name']) ? $item['name'] : '',
  );

  // Make sure we aren't a vegetarian poutine restaurant before showing the meat options
  $allow_meat = isset($instance['settings']['allow_meat']) ? $instance['settings']['allow_meat'] : TRUE;

  if ($allow_meat) {
    $element['vegetarian'] = array(
      '#title' => t('Vegetarian'),
      '#type' => 'checkbox',
      '#default_value' => isset($item['vegetarian']) ? $item['vegetarian'] : '',
    );

    // Have a separate fieldset for meat.
    $element['meat'] = array(
      '#title' => t('Meat'),
      '#type' => 'fieldset',
      '#process' => $process,

      // the meat fieldset should only be visible if
      // the vegetarian checkbox is not checked.
      '#states' => array(
        'visible' => array(
          _poutine_maker_make_jquery_selector($field_name, $langcode, $delta, 'vegetarian') =>
            array('checked' => FALSE),
        ),
      ),
    );

    // Create a checkbox item for each meat on the menu
    foreach (poutine_maker_toppings_meat() as $meat_machine=>$meat) {
      $element['meat'][$meat_machine] = array(
        '#title' => t($meat),
        '#type' => 'checkbox',
        '#default_value' => isset($item[$meat_machine]) ? $item[$meat_machine] : '',
      );
    }
  }

  // Have a separate fieldset for non-meat toppings
  $element['toppings'] = array(
    '#title' => t('Toppings'),
    '#type' => 'fieldset',
    '#process' => $process,
  );

  // Create a checkbox item for each topping on the menu
  foreach (poutine_maker_toppings_veg() as $topping_machine=>$topping) {
    $element['toppings'][$topping_machine] = array(
      '#title' => t($topping),
      '#type' => 'checkbox',
      '#default_value' => isset($item[$topping_machine]) ? $item[$topping_machine] : '',
    );
  }

  return $element;
}

/**
 * _poutine_maker_make_jquery_selector() returns a jQuery selector that Drupal will use
 * to test for #states conditions.
 */
function _poutine_maker_make_jquery_selector($field_name, $langcode, $delta, $item_name) {
  $lastpart = implode('][', array($langcode, $delta, $item_name));
  return ':input[name="' . $field_name . '[' . $langcode . '][' . $delta . '][' . $item_name . ']"], ' .
    ':input[name$="[' . $field_name . '][' . $langcode . '][' . $delta . '][' . $item_name . ']"]';
}

/**
 * Process callback to remove one level of parentage
 *
 * poutine_maker_ignore_parent() causes the form values to be 'flattened' before being saved into
 * the database table.
 */
function poutine_maker_ignore_parent(&$form, &$form_state, $complete) {
  array_pop($form['#parents']);
  return $form;
}

/**
 * Implements hook_field_is_empty().
 *
 * poutine_maker_field_is_empty() lets Drupal know whether or not to process input
 * at all; if the field is empty, it won't bother validating
 * or saving the values.
 */
function poutine_maker_field_is_empty($item, $field) {
  $has_stuff = FALSE;
  foreach (poutine_maker_toppings() as $topping_machine=>$topping) {
    if (isset($item[$topping_machine]) && $item[$topping_machine] == 1) {
      $has_stuff = TRUE;
    }
  }
  if (!empty($item['name'])) {
    $has_stuff = TRUE;
  }
  if (isset($item['vegetarian']) && $item['vegetarian'] == 1) {
    $has_stuff = TRUE;
  }
  return !$has_stuff;
}

/**
 * Implements hook_field_validate().
 *
 * poutine_maker_field_validate() sets an $errors array with information about
 * the errors detected in the field input.
 */
function poutine_maker_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  foreach ($items as $delta => $item) {
    if (isset($item['sweet_potato']) && isset($item['tofu']) && $item['sweet_potato'] == 1 && $item['tofu'] == 1) {
      $errors[$field['field_name']][$langcode][$delta][] = array(
        'error' => 'poutine_maker_invalid_full',
        'message' => t('%title: Your poutine is not tasty. Please do not mix sweet potato and tofu.', array('%title' => $instance['label'])),
      );
    }
  }
}

/**
 * Implements hook_field_widget_error().
 *
 * poutine_maker_field_widget_error() takes the errors set in poutine_maker_field_validate()
 * and tells Drupal how to notify the user of the error. For example, this implementation
 * calls form_error() with each element passed in the $error['error_elements'] array, so
 * we can identify a problem with several elements in our field (e.g. tofu and sweet potato).
 */
function poutine_maker_field_widget_error($element, $error, $form, &$form_state) {
  switch ($error['error']) {
  // Handle the error that was set in poutine_maker_field_validate()
  case 'poutine_maker_invalid_full':
    form_error($element, $error['message']);
    break;
  }
}

/**
 * Implements hook_field_instance_settings_form().
 *
 * poutine_maker_field_instance_settings_form() modifies the instance settings
 * form to include a checkbox that allows the administrator to choose whether
 * to even give the option of choosing meat (they might want to open a vegetarian
 * poutine restaurant).
 */
function poutine_maker_field_instance_settings_form($field, $instance) {
  $settings = $instance['settings'];
  $form['allow_meat'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow meat on the menu.'),
    '#default_value' => isset($settings['allow_meat']) ? $settings['allow_meat'] : 0,
  );
  return $form;
}
