<!DOCTYPE html>
<head><title>Poutine Maker: An Introduction to the Field API in Drupal 7</title></head>
<style>
  body {
    width: 585px;
    font-family: Arial;
    font-size: 0.875em;
    line-height: 1.286em;
  }
  h1 {
    line-height: 2.086em;
  }
  h1 {
    line-height: 1.286em;
  }
</style>
<body>

<h1>Poutine Maker: An Introduction to the Field API in Drupal 7 (Part 2)</h1>

<p>In <a href="http://evolvingweb.ca/story/poutine-maker-introduction-field-api-drupal-7-part-1">part 1</a> of this tutorial, I covered how to make your own custom field and widget. Here I'll cover how to validate that input and format it for the user.</p>

<p>So far, we've:</p>

<ol>
<li>Created a new field type,</li>
<li>Created a new field widget,</li>
<li>Defined the field widget; and</li>
<li>Defined our <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_is_empty()</span>.</li>
</ol>

<p>And by the end of this blog post, we'll have:</p>

<ol start="5">
<li>Created a validator to detect input errors,</li>
<li>Defined how our widget should handle any detected errors; and</li>
<li>Created a formatter to display the saved values.</li>
</ol>

<p>If you're confused about the terminology, remember this:</p>

<ul>
<li>A <strong>field</strong> is a data type. For example, you could have a colour field that only stores colours.</li>
<li>A <strong>widget</strong> is a method of entering data into the field. For example, you could use a colour picker to let users enter colours. Or, you could let the user type the colour name into a textbox.</li>
<li>A <strong>formatter</strong> is a way to display the stored field data. For example, you could display a chosen colour by displaying the name of the colour, or an image of that colour.</li>
</ul>

<p>It's important to remember that you can define widgets and formatters on existing fields. Not only that, but you can use existing formatters and widgets for new fields.</p>

<h2>The Challenge</h2>

<p>Those who missed the <a href="http://evolvingweb.ca/story/poutine-maker-introduction-field-api-drupal-7-part-1">first part</a> of this series will want to know why I'm defining all this custom field stuff. The challenge I gave myself in part 1 was to make a multi-value Poutine Maker field. I wanted people to be able to design their own Poutines. Poutine Maker was the result.</p>

<h2>Field API Hooks</h2>

<p>Let's review the main hooks in the Field API I covered in the first part of this series:</p>

<ul>
<li><span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_info()</span> tells Drupal about your custom fields.</li>
<li><span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_widget_info()</span> tells Drupal about your custom field widgets.</li>
<li><span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_widget_form()</span> tells Drupal the structure of your custom field widget, so that a form can be displayed to the user.</li>
<li><span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_is_empty()</span> tells Drupal how to tell whether or not the user has entered any data worth saving.</li>
</ul>

<p>In this part of the tutorial, I'll cover the following hooks:</p>

<ul>
<li><span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_validate()</span> tells Drupal about any errors detected in the submitted data.</li>
<li><span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_widget_error()</span> tells Drupal how to handle errors detected in <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_widget_error()</span>.</li>
<li><span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_formatter_info()</span> tells Drupal about your custom field formatters.</li>
<li><span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_formatter_view()</span> tells Drupal how to display the data in your field to the user.</li>
</ul>

<h2>Step 5: Create a field validator with hook_field_validate()</h2>

<p>Before we get to the field formatter, we should write a field validator so we can be sure that the data entered by the user is good enough to save.</p>

<p>Here's the field validation in action. I selected tofu and sweet potato as toppings for my poutine like so:</p>

<p><img src="tofu_and_sweetpotato.png" alt="Tofu and Sweet Potato" title="" /></p>

<p>However, that's kind of gross, so I've designed a validator to prevent people from choosing that combination of toppings:</p>

<p><img src="tofu%20validation%20error.png" alt="Tofu error" title="" /></p>

<p>There are two main hooks used to enforce field validation. The first of the two hooks is <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_validate()</span>, which simply checks the field's values for errors and sets any error messages in the $errors array.</p>

<pre><code>
function poutine_maker_field_validate($entity_type, $entity,
          $field, $instance, $langcode, $items, &$errors) {
  foreach ($items as $delta => $item) {
    if (isset($item['sweet_potato']) &&
        isset($item['tofu']) &&
        $item['sweet_potato'] == 1 &&
        $item['tofu'] == 1) {

      $errors[$field['field_name']][$langcode][$delta][] = array(
        'error' => 'poutine_maker_invalid_full',
        'message' => t(
          '%title: Your poutine is not tasty. '.
          'Please do not mix sweet potato and tofu.',
          array('%title' => $instance['label'])
        ),
      );
    }
  }
}
</code>
</pre>

<p>This code looks at all the poutines entered in our poutine field, and figures out if any of them have selected both tofu and sweet potato. If so, we set an error called 'poutine_maker_invalid_full' with an error message. <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>poutine_maker_field_widget_error()</span> is necessary for this error message to actually be rendered.</p>

<p>'poutine_maker_invalid_full' is an error code chosen by you. This is used because <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_widget_error()</span> can handle errors differently based on what <em>kind</em> of error it is.</p>

<p><span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>poutine_maker_field_validate()</span> will communicate with <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>poutine_maker_field_widget_error()</span> using the <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>$errors</span> array. <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>$errors</span> is a container for all the useful information about the errors in a field widget. This is where you store error messages and indicate which element the error occurred on.</p>

<p>Let's take a look at the <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_widget_error()</span> code:</p>

<pre><code>
function poutine_maker_field_widget_error($element, $error,
                                      $form, &$form_state) {
  switch ($error['error']) {
  // Handle the error that was set in
  // poutine_maker_field_validate()
  case 'poutine_maker_invalid_full':
    form_error($element, $error['message']);
    break;
  }
}
</code>
</pre>

<p>The switch statement is just to check what type of error it is. In this case we only have one type of possible error, but I've included the switch statement anyways to illustrate the flexibility.</p>

<h2>Step 6: Define your field formatter with hook_field_formatter_info()</h2>

<p><span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_formatter_info()</span> tells Drupal about the formatters your module is making available. Here's an example:</p>

<pre><code>
function poutine_maker_field_formatter_info() {
  return array(
    'poutine_maker_poutine_formatter' => array(
      'label' => t('Default'),
      'field types' => array('poutine_maker_poutine'),
    ),
  );
}
</code>
</pre>

<p>'poutine_maker_poutine_formatter' is the machine-readable name of the field formatter. This is how other hooks can tell what kind of formatter is being used (if, for example, your module defined more than one formatter).</p>

<p><span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>'field types' => array('poutine_maker_poutine')</span> means that this formatter will format <em>only</em> the 'poutine_maker_poutine' field type. If your formatter was fairly generic like a text box, it could work for text fields, date fields, or colour fields.</p>

<p>Now that we've defined a formatter, we can see the choice on the 'Manage Display' tab of an entity:</p>

<p><img src="poutine_order_new_field.png" alt="New field" title="" /></p>

<h2>Step 7: Define how your field should be formatted with hook_field_formatter_view()</h2>

<p>Now we just need to give the Field API a renderable array to display to the user. I like to have one generic implementation of <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_formatter_view()</span> that delegates construction of the array to a separate function. This makes it easy to add formatters.</p>

<p>Here is <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_formatter_view()</span>:</p>

<pre><code>
function poutine_maker_field_formatter_view($entity_type, $entity, $field,
                                  $instance, $langcode, $items, $display) {
  $element = array();
  foreach ($items as $delta => $item) {
    $element[$delta] = poutine_maker_format_field($item);
  }
  return $element;
}
</code>
</pre>

<p>Notice that this function returns an $element array, keyed by $delta (each $delta refers to an item in a multi-value field). I render each element item in a separate function called <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>poutine_maker_format_field()</span>. This is not a hook, but rather a helper function to keep my <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_formatter_view()</span> implementation clean and short.</p>

<p>Here is my <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>poutine_maker_format_field()</span> function. It starts out with a 'container' element. This is similar to the Form API's fieldset type.</p>

<pre><code>
function poutine_maker_format_field($item) {
  $element = array(
    '#type' => 'container',
    '#attributes' => array( 'class' => array( 'field-item') ),
  );

  // ...
</code>
</pre>

<p>Next, I add the name of the poutine:</p>

<pre><code>
$element['name'] = array(
  'label' => array(
    '#type' => 'container',
    '#attributes' => array( 'class' => array( 'field-label' )),
    'text' => array(
      '#markup' => t('Name'),
    ),
  ),
  'item' => array(
    '#type' => 'container',
    '#attributes' => array( 'class' => array( 'field-item') ),
    'text' => array(
      '#markup' => $item['name'],
    ),
  ),
);
</code>
</pre>

<p>Next, I check to see if the poutine is vegetarian. If the poutine is vegetarian, I add a little note that says so:</p>

<pre><code>
if ($item['vegetarian']) {
  $element['vegetarian'] = array(
    'item' => array(
      '#type' => 'container',
      '#attributes' => array( 'class' => array( 'field-item') ),
      'text' => array(
        '#markup' => t('&lt;strong&gt;This is a vegetarian poutine&lt;/strong&gt;'),
      ),
    ),
  );
}
</code>
</pre>

<p>The only thing left is the ingredients. The simplest output for me is to just list the ingredients in the poutine:</p>

<pre><code>
  $toppings_list = array();
  foreach (poutine_maker_toppings() as $topping_machine=>$topping) {
    if ($item[$topping_machine] == 1) {
      $toppings_list[] = t($topping);
    }
  }
  $toppings_rendered_list = implode(', ', $toppings_list);
  $element['toppings'] = array(
    'label' => array(
      '#type' => 'container',
      '#attributes' => array( 'class' => array( 'field-label' )),
      'text' => array(
        '#markup' => t('Ingredients'),
      ),
    ),
    'item' => array(
      '#type' => 'container',
      '#attributes' => array( 'class' => array( 'field-item') ),
      'text' => array(
        '#markup' => $toppings_rendered_list,
      ),
    ),
  );
</code>
</pre>

<p>This code simply creates a comma-separated list of ingredients, and then sticks that list in a div. The Render API arrays are verbose, but it allows you to avoid writing markup.</p>

<p>The only thing left to do is to return the renderable element item. Remember that this is only one item in a multi-value field. This is not a requirement; it is just the way I have organized my code.</p>

<pre><code>
  return $element;
}
</code>
</pre>

<p>Here is the formatter in action:</p>

<p><img src="poutine_formatter_inaction.png" alt="Formatter in action" title="" /></p>

<h2>A More Advanced Formatter</h2>

<p>The basic formatter works, but I wanted to format my field data in an exciting way using the HTML Canvas API. Here's the PHP code that creates the canvas tag:</p>

<p>The first step is to add my Javascript file to the page.</p>

<pre><code>
function poutine_maker_format_canvas_field($item) {
  drupal_add_js(drupal_get_path('module', 'poutine_maker') . '/poutine_maker.js');
</code>
</pre>

<p>Next, I create a container for my canvas element:</p>

<pre><code>
  $element = array(
    '#type' => 'container',
    '#attributes' => array( 'class' => array( 'field-item') ),
  );
</code>
</pre>

<p>Here's where I create the canvas element itself. I generate a unique ID for it so I can keep track of it.</p>

<pre><code>
  $canvas_id = 'poutine_maker_' . md5(rand());
  $canvas = '&lt;canvas width="500" height="500" class="poutine-maker-animation" id="' . $canvas_id . '"&gt;&lt;/canvas&gt;';
</code>
</pre>

<p>I then create a JSON data array for my Javascript to use. It includes the URLs for the ingredient photos, the title of the poutine, and a few other things. I include the JSON in the page with <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>drupal_add_js()</span>.</p>

<pre><code>
  foreach (poutine_maker_toppings() as $topping_machine=>$topping) {
    if ($item[$topping_machine] == 1) {
      $toppings_list[] = $topping;
      $toppings_list_img[] = drupal_get_path('module', 'poutine_maker') . '/' . $topping_machine . '.jpg';
    }
  }

  // Give the &lt;canvas&gt; animation some data to work with.
  $json = array(
    'title' => $item['name'],
    'toppings' => $toppings_list_img,
    'bg' => drupal_get_path('module', 'poutine_maker') . '/poutine_background.jpg',
    'vegetarian' => ($item['vegetarian'] == 1),
    'fork' => drupal_get_path('module', 'poutine_maker') . '/fork.png',
  );
  $js = 'window[\'' . $canvas_id . '\'] = ' . json_encode($json) . ';';
  drupal_add_js($js, 'inline');
</code>
</pre>

<p>Finally, I add the canvas to the renderable array, and return the element to be rendered.</p>

<pre><code>
  $element['text'] = array (
    '#markup' => $canvas,
  );
  return $element;
}
</code>
</pre>

<p>There's a ton of Javascript involved here that I won't get into. The gist of it is I look for canvases with the '.poutine-maker-animation' class, load the data associated with that canvas element, and run the animation with the included photos.</p>

<p><span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>poutine_maker_field_formatter_view()</span> must be tweaked to support more than one widget type, but I won't include the code here (if you're curious, see the code on <a href="https://github.com/tarmstrong/poutine_maker">github</a> or <a href="http://drupal.org/sandbox/tarmstrong/1188140">drupal.org</a>). Here's the updated <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_formatter_info()</span>. Note the additional entry.</p>

<pre><code>
function poutine_maker_field_formatter_info() {
  return array(
    'poutine_maker_poutine_formatter' => array(
      'label' => t('Default'),
      'field types' => array('poutine_maker_poutine'),
    ),
    'poutine_maker_poutine_canvas' => array(
      'label' => t('Canvas Formatter'),
      'field types' => array('poutine_maker_poutine'),
    ),
  );
}
</code>
</pre>

<p>Click the below image for the demo. This demo should work in Chrome and Firefox 4+.</p>

<p><a href="http://demo">
<img src="awesome_best_poutine_cropped.png" alt="Poutine Formatter Demo" title="" />
</a></p>

<h2>Review</h2>

<p>Here's a review of the entire custom field process:</p>

<ol>
<li>Define your custom field with <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_info()</span></li>
<li>Tell Drupal about your custom field widget with <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_widget_info()</span></li>
<li>Define your custom field widget with <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_widget_form()</span></li>
<li>Let Drupal know when your field is empty with <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_is_empty()</span></li>
<li>Define your custom field validator with <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_validate()</span></li>
<li>Let Drupal know about your custom field formatter with <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_formatter_info()</span></li>
<li>Define how your field should be formatted with <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>hook_field_formatter_view()</span></li>
</ol>

<p>The example code covered in this tutorial are available on <a href="https://github.com/tarmstrong/poutine_maker">github</a> and <a href="http://drupal.org/sandbox/tarmstrong/1188140">drupal.org</a>. They are heavily commented and cover more material than I could in these posts.</p>

<p>As always, comment if you have questions or suggestions. If you're using custom fields in interesting ways, let us know!</p>

<h2>Notes</h2>

<p>The Field API hooks that I covered support multiple fields, multiple widgets, and multiple formatters. A good example is the <a href="http://drupal.org/project/date">Date</a> module, which defines <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>date</span>, <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>datestamp</span>, and <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>datetime</span> fields. The Date module defines several different widgets for these fields as well: <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>date_text</span> and <span style='font-family:"Courier New","DejaVu Sans Mono", monospace'>date_select</span> are two examples. I recommend reading the Date module's code to see a rich example of custom fields types in Drupal 7.</p>

<h2>Additional Resources</h2>

<ul>
<li>The <a href="http://drupal.org/project/examples">Examples Module</a></li>
<li><a href="http://api.drupal.org/api/drupal/modules--field--field.module/group/field/7">Field API</a></li>
<li><a href="http://api.drupal.org/api/drupal/developer--topics--forms_api_reference.html/7">Form API</a></li>
<li><a href="http://www.drupalbook.com/">Pro Drupal Development</a></li>
<li><a href="https://www.packtpub.com/drupal-7-module-development/book">Drupal 7 Module Development</a></li>
</ul>
